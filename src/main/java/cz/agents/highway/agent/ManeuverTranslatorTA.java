package cz.agents.highway.agent;

import cz.agents.highway.environment.roadnet.Lane;
import cz.agents.highway.maneuver.*;
import cz.agents.highway.protobuf.generated.simplan.PlanMessage;
import cz.agents.highway.storage.RoadObject;
import cz.agents.highway.storage.VehicleSensor;
import cz.agents.highway.storage.plan.ManeuverAction;
import cz.agents.highway.storage.plan.Action;
import cz.agents.highway.storage.plan.WPAction;

import javax.vecmath.Point2f;
import javax.vecmath.Point3f;
import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * This class translates maneuvers generated by SDAgent to waypoints
 * Created by wmatex on 15.7.14.
 */
public class ManeuverTranslatorTA {
    private static final double RADIUS = 1f;

    private static final double MAX_ANGLE = Math.PI/2;

    private static final int TRY_COUNT = 10;

    private static final float WAYPOINT_DISTANCE = 3.0f;
    private static float MAX_SPEED = 20;
    private double lastUpateTime;


    private static final float EPSILON = 0.01f;

    private VehicleSensor sensor;
    private final RouteNavigator navigator;
    private final int id;

    public ManeuverTranslatorTA(int id, RouteNavigator navigator) {
        this.id = id;
        this.navigator = navigator;
    }

    public void setSensor(VehicleSensor sensor) {
        this.sensor = sensor;
    }
    public List<Action> translate(CarManeuver maneuver,Lane myLane) {
        if (maneuver == null) {
            LinkedList<Action> actions = new LinkedList<Action>();
            Point2f initial = navigator.getInitialPosition();
            actions.add(new WPAction(id, 0d, new Point3f(initial.x, initial.y, 0), 0));
            return  actions;
        }
        RoadObject me = sensor.senseCurrentState();
        // Check the type of maneuver
        if ((maneuver instanceof StraightManeuver) || (maneuver instanceof AccelerationManeuver)
                || (maneuver instanceof DeaccelerationManeuver)) {
            return generateWaypointInLane(0, maneuver, myLane);
        } else if (maneuver instanceof LaneLeftManeuver) {
            return generateWaypointInLane(/*me.getLaneIndex() + 1*/ 29, maneuver, myLane);
        } else if (maneuver instanceof LaneRightManeuver) {
            return generateWaypointInLane(/*me.getLaneIndex() - 1*/ -29, maneuver, myLane);
        } else {
            LinkedList<Action> actions = new LinkedList<Action>();
            ManeuverAction res = new ManeuverAction(sensor.getId(), maneuver.getStartTime() / 1000.0,
                    maneuver.getVelocityOut(), maneuver.getLaneOut(), maneuver.getDuration());
            actions.add(res);
            return actions;
        }
    }
    //TODO Code duplicate with route agent
    //TODO use point close enough method from original Maneuver Translator
    private List<Action> generateWaypointInLane(int relativeLane, CarManeuver maneuver,Lane myLane) {
        RoadObject me = sensor.senseCurrentState();
        LinkedList<Action> actions = new LinkedList<Action>();
        int nearestWaipoint = getNearestWaipointIndex(me, myLane);

        ArrayList<Point3f> points;  // list of points on the way, used to be able to set speed to the action later

        int wpCount = (int)me.getVelocity().length() +1; // how many waypoints before me will be calculated.
        points =  new ArrayList<Point3f>();
        navigator.setCheckpoint();

        Point2f position2D = new Point2f(me.getPosition().getX(), me.getPosition().getY());

        List<Point2f> wps = new LinkedList<Point2f>();
        Point2f waypoint = null;

        //try to advance navigator closer to the actual position
        int maxMove = 10;  // how many points will be tried.
        //how many waiponts ahead will be chcecked depending on the update time
        maxMove = (int)(((me.getUpdateTime() - lastUpateTime)*MAX_SPEED)/1000) + 5;
        if(maxMove < 10) maxMove = 10;
        String uniqueIndex = navigator.getUniqueLaneIndex();
        // finding the nearest wayipont, if changing lane, set the first of the new lane.
        while (maxMove-- > 0 && navigator.getRoutePoint().distance(position2D) > WAYPOINT_DISTANCE / 2 && navigator.getUniqueLaneIndex().equals(uniqueIndex)) {
            navigator.advanceInRoute();
        }
        // finding the nearest waipoint in the new lane.
        if(!navigator.getUniqueLaneIndex().equals(uniqueIndex))
        {
            float initialPos = position2D.distance(navigator.getRoutePoint());
            do{
                navigator.advanceInRoute();
            }while(position2D.distance(navigator.getRoutePoint())  < initialPos);

        }
        // waipoint not found, reset back
        if( navigator.getRoutePoint().distance(position2D) > WAYPOINT_DISTANCE / 2 && navigator.getUniqueLaneIndex().equals(uniqueIndex)){
            navigator.resetToCheckpoint();
        }else {
            navigator.setCheckpoint();
        }

        if (relativeLane < 0) {
            navigator.changeLaneRight();
            navigator.setCheckpoint();
        } else if (relativeLane > 0) {
            navigator.changeLaneLeft();
            navigator.setCheckpoint();
        }
        waypoint = navigator.getRoutePoint();



        float minSpeed = Float.MAX_VALUE; // minimal speed on the points before me
        //TODO fix than distance of waipoints is different than 1
        for(int i=0;i<=maneuver.getPositionOut() || i<wpCount;i++)
        {
            // move 3 waipoints ahead
            while (waypoint.distance(navigator.getRoutePoint()) < WAYPOINT_DISTANCE){
                navigator.advanceInRoute();
            }
            waypoint = navigator.getRoutePoint();
            wps.add(waypoint);
            // vector from my position to the next waypoint
            Vector3f toNextPoint = new Vector3f(waypoint.x- me.getPosition().x,waypoint.y - me.getPosition().y,0);
            Vector3f velocity = me.getVelocity();
            float angle = velocity.angle(toNextPoint); // angle between my velocity and vector to the next point
            float speed;
            if(Float.isNaN(angle))
            {
                speed = 1;
            }
            else {
                if (angle < 0.4) speed = MAX_SPEED; // if the curve is less than 20 degrees, go by the max speed.
                else if (angle > 6) speed = 2;    // minimal speed for curves.
                else {
                    speed = 1 / angle * 6;
                }
            }
            if(speed < minSpeed) minSpeed = speed;  // all the next actions get the minimal speed.
            points.add(i,new Point3f(waypoint.x, waypoint.y, me.getPosition().z));
        }
        if(minSpeed > maneuver.getVelocityOut())
        {
            minSpeed = (float)maneuver.getVelocityOut();
        }
        for(int i=0;i<=maneuver.getVelocityOut() && i<wpCount;i++)
        {
            actions.add(new WPAction(sensor.getId(), me.getUpdateTime(),points.get(i),minSpeed));
        }


        navigator.resetToCheckpoint();
        lastUpateTime = me.getUpdateTime();
        return actions;

    }

    private WPAction point2Waypoint(Point2f point, CarManeuver maneuver) {
        return new WPAction(sensor.getId(), maneuver.getStartTime() / 1000,
                new Point3f(point.x, point.y, sensor.senseCurrentState().getPosition().z),
                maneuver.getVelocityOut());
    }

    /**
     * This method determines whether the waypoint candidate is close enough (in radius) to the position
     * in the direction given by velocity vector
     *
     * @param innerPoint Waypoint candidate
     * @param position   Position
     * @param velocity   Velocity vector
     * @return
     */
    public boolean pointCloseEnough(Point2f innerPoint, Point2f position, Vector2f velocity) {
        // Direction vector of waypoint candidate relative to position
        Vector2f direction = new Vector2f();
        direction.sub(innerPoint, position);

        return  velocity.angle(direction) < MAX_ANGLE &&
                distance(innerPoint, position, direction, velocity) < RADIUS;
    }

    /**
     * This method computes the distance of the waypoint. It is the Euklidian distance of the waypoint
     * multiplied by absolute value of the sin of the angle between the direction of the waypoint
     * and the vector of velocity. This ensures, that waypoints that are less deviating from
     * the direction of the vehicle's movement and are close enough are picked.
     */
    private float distance(Point2f innerPoint, Point2f position, Vector2f direction, Vector2f velocity) {
        float d = innerPoint.distance(position);
        return d*d*Math.abs((float)Math.sin(direction.angle(velocity))+EPSILON);
    }
    // TODO FIX CODE DUPLICATE WITH testAgent and close enough
    private int getNearestWaipointIndex(RoadObject state,Lane myLane)
    {
        int myIndexOnRoute = 0;

        // while(!maneuverTranslator.pointCloseEnough(myLane.getInnerPoints().get(myIndexOnRoute),new Point2f(state.getPosition().x,state.getPosition().y),new Vector2f(state.getVelocity().x,state.getVelocity().y)))
        float test = diss(myLane.getInnerPoints().get(myIndexOnRoute),new Point2f(state.getPosition().x,state.getPosition().y));
        while(diss(myLane.getInnerPoints().get(myIndexOnRoute),new Point2f(state.getPosition().x,state.getPosition().y))  > 5) // Magical value
        {
            myIndexOnRoute++;  //TODO fix this
            if(myLane.getInnerPoints().size() == myIndexOnRoute)
            {
                myIndexOnRoute--;
                break;
            }
        }
        while(diss(myLane.getInnerPoints().get(myIndexOnRoute),new Point2f(state.getPosition().x,state.getPosition().y))  <= 5)
        {
            myIndexOnRoute++;  //TODO fix this
            if(myLane.getInnerPoints().size() == myIndexOnRoute)
            {
                myIndexOnRoute--;
                break;
            }
        }
        return  myIndexOnRoute;
    }
    // TODO FIX CODE DUPLICATE WITH testAgent
    public float diss(Point2f innerPoint, Point2f position) {
        return innerPoint.distance(position);

    }
}
